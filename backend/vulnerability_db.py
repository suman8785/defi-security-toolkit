import sqlite3
import json
from datetime import datetime
from typing import Dict, List, Any
from pathlib import Path
import streamlit as st
import os

class VulnerabilityDatabase:
    """Local database for vulnerability patterns and historical data"""
    
    def _init_(self):
        # Use temporary directory on Streamlit Cloud
        if hasattr(st, 'secrets'):
            # On Streamlit Cloud, use temp directory
            self.db_path = Path("/tmp/vulnerability_db.sqlite")
        else:
            # Local deployment
            from config import BASE_DIR
            self.db_path = BASE_DIR / "vulnerability_db.sqlite"
        
        self._init_database()
    
    def _init_database(self):
        """Initialize database tables"""
        try:
            conn = sqlite3.connect(str(self.db_path))
            cursor = conn.cursor()
            
            # Vulnerability patterns table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS vulnerability_patterns (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    pattern TEXT NOT NULL,
                    severity TEXT NOT NULL,
                    description TEXT,
                    recommendation TEXT,
                    cwe_id TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Historical findings table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS findings_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    contract_hash TEXT NOT NULL,
                    vulnerability_type TEXT NOT NULL,
                    severity TEXT NOT NULL,
                    tool TEXT NOT NULL,
                    details TEXT,
                    found_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # Known exploits table
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS known_exploits (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    description TEXT,
                    exploit_code TEXT,
                    affected_contracts TEXT,
                    damage_usd REAL,
                    date_occurred DATE,
                    references TEXT
                )
            """)
            
            conn.commit()
            conn.close()
            
            # Populate with initial data
            self._populate_initial_data()
        except Exception as e:
            print(f"Database initialization error: {e}")
            # Continue without database on error
    
    def _populate_initial_data(self):
        """Add common vulnerability patterns"""
        try:
            patterns = [
                {
                    'name': 'Reentrancy',
                    'pattern': r'\.call\{.\}$.$.\n.*state.=',
                    'severity': 'critical',
                    'description': 'External call before state update',
                    'recommendation': 'Use checks-effects-interactions pattern',
                    'cwe_id': 'CWE-841'
                },
                {
                    'name': 'Integer Overflow',
                    'pattern': r'\+\+|--|\+=|-=|\*=',
                    'severity': 'high',
                    'description': 'Arithmetic operation without overflow check',
                    'recommendation': 'Use SafeMath or Solidity 0.8+',
                    'cwe_id': 'CWE-190'
                }
            ]
            
            conn = sqlite3.connect(str(self.db_path))
            cursor = conn.cursor()
            
            for pattern in patterns:
                cursor.execute("""
                    INSERT OR IGNORE INTO vulnerability_patterns 
                    (name, pattern, severity, description, recommendation, cwe_id)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (
                    pattern['name'],
                    pattern['pattern'],
                    pattern['severity'],
                    pattern['description'],
                    pattern['recommendation'],
                    pattern['cwe_id']
                ))
            
            conn.commit()
            conn.close()
        except Exception as e:
            print(f"Error populating data: {e}")
    
    def get_vulnerability_patterns(self) -> List[Dict[str, Any]]:
        """Get all vulnerability patterns"""
        try:
            conn = sqlite3.connect(str(self.db_path))
            cursor = conn.cursor()
            
            cursor.execute("SELECT * FROM vulnerability_patterns")
            patterns = []
            
            for row in cursor.fetchall():
                patterns.append({
                    'id': row[0],
                    'name': row[1],
                    'pattern': row[2],
                    'severity': row[3],
                    'description': row[4],
                    'recommendation': row[5],
                    'cwe_id': row[6]
                })
            
            conn.close()
            return patterns
        except:
            # Return default patterns if database fails
            return [
                {
                    'id': 1,
                    'name': 'Reentrancy',
                    'pattern': 'call.*state',
                    'severity': 'critical',
                    'description': 'External call before state update',
                    'recommendation': 'Use checks-effects-interactions pattern',
                    'cwe_id': 'CWE-841'
                }
            ]
    
    def add_finding(self, contract_hash: str, vulnerability: Dict[str, Any], tool: str):
        """Record a vulnerability finding"""
        try:
            conn = sqlite3.connect(str(self.db_path))
            cursor = conn.cursor()
            
            cursor.execute("""
                INSERT INTO findings_history 
                (contract_hash, vulnerability_type, severity, tool, details)
                VALUES (?, ?, ?, ?, ?)
            """, (
                contract_hash,
                vulnerability.get('title', 'Unknown'),
                vulnerability.get('severity', 'unknown'),
                tool,
                json.dumps(vulnerability)
            ))
            
            conn.commit()
            conn.close()
        except Exception as e:
            print(f"Error adding finding: {e}")
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get vulnerability statistics"""
        try:
            conn = sqlite3.connect(str(self.db_path))
            cursor = conn.cursor()
            
            # Most common vulnerabilities
            cursor.execute("""
                SELECT vulnerability_type, COUNT(*) as count
                FROM findings_history
                GROUP BY vulnerability_type
                ORDER BY count DESC
                LIMIT 10
            """)
            
            common_vulns = [
                {'type': row[0], 'count': row[1]} 
                for row in cursor.fetchall()
            ]
            
            conn.close()
            
            return {
                'common_vulnerabilities': common_vulns,
                'severity_distribution': {},
                'tool_effectiveness': {}
            }
        except:
            return {
                'common_vulnerabilities': [],
                'severity_distribution': {},
                'tool_effectiveness': {}
            }

# Module-level instance
vuln_db = VulnerabilityDatabase()

def get_patterns() -> List[Dict[str, Any]]:
    return vuln_db.get_vulnerability_patterns()

def record_finding(contract_hash: str, vulnerability: Dict[str, Any], tool: str):
    vuln_db.add_finding(contract_hash, vulnerability, tool)

def get_stats() -> Dict[str, Any]:
    return vuln_db.get_statistics()
